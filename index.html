<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MCQ Notes Driller</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#121823; --muted:#8aa0b3; --text:#e7eef6; --accent:#68b2ff; --good:#37d399;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
      background:linear-gradient(180deg,#0a0e13,#0b1219 40%, #0a0e13); color:var(--text);
      display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .app{width:min(1100px,100%);}
    .card{background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.25); overflow:hidden}
    header{display:flex; gap:12px; align-items:center; justify-content:space-between; padding:16px 20px; border-bottom:1px solid rgba(255,255,255,.06)}
    header h1{font-size:18px; margin:0; letter-spacing:.2px}
    header .meta{display:flex; gap:14px; align-items:center; color:var(--muted); font-size:13px; flex-wrap:wrap}
    header .pill{background:rgba(255,255,255,.06); padding:6px 10px; border-radius:999px; display:flex; align-items:center; gap:6px}
    .tabs{display:flex; gap:8px; align-items:center}
    .tab{background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,.08); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700}
    .tab.active{background:var(--accent); color:#08121b; border-color:transparent}
    .ghost{background:transparent; color:var(--muted)}
    .soft{background:rgba(255,255,255,.08); color:var(--text)}
    .primary{background:var(--accent); color:#08121b}
    .ok{background:var(--good); color:#08120d}
    .disabled{opacity:.6; cursor:not-allowed}
    button{appearance:none; border:0; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; transition:.15s transform,.15s background,.15s opacity}
    button:active{transform:translateY(1px)}
    .view{display:none; padding:20px}
    .view.active{display:block}
    .panel{border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:16px; margin-bottom:12px}
    .panel h2{font-size:16px; margin:0 0 10px 0; color:#cfe6ff}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .kbd{font-family:ui-monospace,Consolas,monospace; background:#0d1420; border:1px solid rgba(255,255,255,.1); padding:2px 6px; border-radius:6px}
    textarea{width:100%; min-height:260px; resize:vertical; background:#0e141d; color:var(--text); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:12px; font-family:ui-monospace,Consolas,monospace}
    .question{font-size:20px; line-height:1.4; margin-bottom:14px}
    .options{display:grid; gap:10px}
    .opt{background:#101722; border:1px solid rgba(255,255,255,.08); padding:12px 14px; border-radius:12px; text-align:left; font-weight:600; color:white; outline:0}
    .opt.correct{border-color:rgba(55,211,153,.8); box-shadow:0 0 0 2px rgba(55,211,153,.25) inset}
    .opt.wrong{border-color:rgba(255,107,107,.8); box-shadow:0 0 0 2px rgba(255,107,107,.25) inset}
    .opt.hovered{outline:2px dashed rgba(184,241,255,.9); outline-offset:2px}
    .notes{margin-top:14px; background:#0e141d; border:1px solid rgba(255,255,255,.06); border-radius:12px; padding:12px; color:#c9d7e5; white-space:pre-wrap}
    .footer{display:flex; justify-content:space-between; align-items:center; margin-top:14px}
    .progress{height:10px; background:#0f1722; border:1px solid rgba(255,255,255,.06); border-radius:999px; overflow:hidden}
    .bar{height:100%; background:linear-gradient(90deg,#68b2ff,#b8f1ff)}
    .hidden{display:none !important}
    /* Level progress bar inside stats */
    .level-bar{height:12px; background:#0f1722; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.06)}
    /* Gamepad tester styles */
    .tester-buttons{display:flex; flex-wrap:wrap; gap:4px; margin-top:8px;}
    .tester-btn{background:#0e141d; border:1px solid rgba(255,255,255,.1); padding:2px 4px; border-radius:6px; font-size:11px; color:var(--text);}
    .tester-btn.active{background:var(--accent); color:#08121b;}
    .tester-axis{position:relative; height:8px; background:#0f1722; border:1px solid rgba(255,255,255,.06); border-radius:999px; overflow:hidden; margin-top:4px;}
    .tester-axis-bar{position:absolute; top:0; height:100%; background:linear-gradient(90deg,#68b2ff,#b8f1ff);}
    .mapping-row{display:flex; gap:4px; align-items:center; margin-top:4px;}
    .mapping-row label{flex:0 0 100px; font-size:12px; color:var(--muted);}
    .mapping-row input{flex:1; background:#0e141d; color:var(--text); border:1px solid rgba(255,255,255,.08); border-radius:6px; padding:4px 6px; font-size:12px;}
  </style>
</head>
<body>
  <div class="app card">
    <header>
      <h1>MCQ Notes Driller</h1>
      <div class="tabs">
        <button id="tab-import" class="tab active" title="Go to Import (I)">Import</button>
        <button id="tab-drill" class="tab" title="Go to Drill (D)">Drill</button>
      </div>
      <div class="meta">
        <span class="pill" id="progressPill">0 / 0</span>
        <span class="pill" id="xpPill">XP: 0 ¬∑ Level 1</span>
        <label class="pill">
          <span class="small muted">Set</span>
          <select id="setSelect" style="background:#0e141d;color:var(--text);border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:4px 6px">
            <option value="" disabled selected>Loading‚Ä¶</option>
          </select>
        </label>
        <button class="soft" id="resetBtn" title="Restart the current set (R)">Restart</button>
      </div>
    </header>
    <!-- IMPORT VIEW -->
    <section id="view-import" class="view active">
      <div class="panel">
        <h2>1) Paste your generated questions (JSON)</h2>
        <p class="muted small">Schema per item: { "id": "unique", "stem": "question text", "options": ["A","B","C","D"], "answer": 0, "notes": "your source notes here" }</p>
        <textarea id="inputArea" placeholder='[
  {
    "id": "ex-1",
    "stem": "Which vitamin deficiency causes night blindness?",
    "options": ["Vitamin A","Vitamin B12","Vitamin C","Vitamin K"],
    "answer": 0,
    "notes": "Vitamin A (retinol) is critical for rhodopsin in rods. Deficiency ‚Üí nyctalopia."
  }
]'></textarea>
        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
          <button class="primary" id="loadBtn">Load Questions</button>
          <button class="soft" id="demoBtn">Load Demo Set</button>
          <button class="ghost" id="downloadTemplateBtn">Download JSON Template</button>
          <button class="ok" id="goDrillBtn" title="Go to Drill (D)">Go to Drill</button>
        </div>
        <p class="muted small" style="margin-top:8px">
          Tips: Paste JSON from ChatGPT ‚Üí <span class="kbd">Load Questions</span>. Options must be exactly 4.
        </p>
      </div>
      <div class="panel">
        <h2>üìà Level & Stats</h2>
        <div id="levelSummary" class="small muted">Earn XP by answering questions correctly. Base: 5 XP per question (halves on retries). Completion bonus: 2.5 √ó number of questions.</div>
        <div class="level-bar" style="margin:8px 0"><div class="bar" id="levelBar" style="width:0%"></div></div>
        <div id="currentLevelBreakdown" class="small muted">No XP earned yet.</div>
      </div>
      <div class="panel">
        <h2>üìÅ Available Question Sets (auto‚Äëloaded from <span class="kbd">/questions/index.json</span>)</h2>
        <div id="setsList" class="small muted">Looking for sets‚Ä¶</div>
      </div>
      <div class="panel">
        <h2>üìä Set Stats</h2>
        <div id="setStats" class="small muted">Run some sets to see stats.</div>
      </div>
      <div class="panel">
        <h2>üéÆ Controller / Keyboard quick map</h2>
        <div class="small muted">
          Keyboard: <span class="kbd">1</span>‚Äì<span class="kbd">4</span> choose ¬∑ <span class="kbd">‚Üê/‚Üí</span> Prev/Next ¬∑ <span class="kbd">R</span> Restart ¬∑ <span class="kbd">I</span>/<span class="kbd">D</span> switch views
          <br/>Gamepad (Nintendo/standard): D‚Äëpad ‚Üë/‚Üì move selection ¬∑ <b>A</b> choose ¬∑ <b>B</b>/Start Next ¬∑ <b>X</b>/L Prev ¬∑ <b>R</b> Next ¬∑ <b>Select</b> Restart ¬∑ <b>Plus</b> Drill ¬∑ <b>Minus</b> Import
        </div>
      </div>

      <!-- Controller configuration and tester panel -->
      <div class="panel" id="controllerConfigPanel">
        <h2>üéÆ Controller Config &amp; Tester</h2>
        <div id="controllerStatus" class="small muted">No gamepad connected.</div>
        <div id="testerButtons" class="tester-buttons"></div>
        <div id="testerAxes" style="margin-top:8px;"></div>
        <div style="margin-top:8px;">
          <label class="small muted">Deadzone: <input type="range" id="deadzoneInput" min="0" max="0.6" step="0.01" value="0.3" style="vertical-align:middle"/></label>
          <span id="deadzoneValue" class="small muted">0.3</span>
        </div>
        <div style="margin-top:4px;">
          <label class="small muted"><input type="checkbox" id="verticalInput" /> Vertical orientation (swap axis)</label>
        </div>
        <div id="mappingList" style="margin-top:8px;"></div>
        <div style="margin-top:8px;">
          <button id="saveConfigBtn" class="soft small">Save Config</button>
          <button id="resetConfigBtn" class="soft small">Reset to Default</button>
        </div>
      </div>
    </section>

    <!-- DRILL VIEW -->
    <section id="view-drill" class="view">
      <div class="quizWrap">
        <div class="panel">
          <h2>2) Drill</h2>
          <div id="quizBox" class="hidden">
            <div class="question" id="stem"></div>
            <div class="options" id="options"></div>
            <div class="notes hidden" id="notes"></div>
            <div class="footer">
              <div style="flex:1; margin-right:12px">
                <div class="progress"><div class="bar" id="bar" style="width:0%"></div></div>
                <div class="small muted" id="statusText" style="margin-top:6px"></div>
              </div>
              <div class="row" style="display:flex; gap:10px">
                <button class="soft" id="prevBtn" disabled>Prev</button>
                <button class="ok" id="nextBtn">Next</button>
              </div>
            </div>
          </div>
          <div id="emptyState" class="center" style="min-height:200px">
            <div class="muted">No questions loaded yet. Go to <span class="kbd">Import</span> to load a set.</div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
  // --- Persistent storage helpers ---
  const PROFILE_KEY = 'mcq_profile_v1';
  const SETS_KEY = 'mcq_sets_v1';
  const EVENTS_KEY = 'mcq_events_v1';
  const SESSION_KEY = 'mcq_session_v1';

  function loadJSON(key, fallback) {
    try {
      const txt = localStorage.getItem(key);
      if (!txt) return fallback;
      return JSON.parse(txt);
    } catch (e) {
      return fallback;
    }
  }
  function saveJSON(key, obj) {
    localStorage.setItem(key, JSON.stringify(obj));
  }

  function loadProfile() {
    let profile = loadJSON(PROFILE_KEY, null);
    if (!profile) {
      profile = { totalXP: 0, level: 1, levelStartXP: 0 };
    }
    // ensure fields
    if (profile.totalXP == null) profile.totalXP = 0;
    if (!profile.level) profile.level = Math.floor(profile.totalXP / 100) + 1;
    if (profile.levelStartXP == null) profile.levelStartXP = Math.floor(profile.totalXP / 100) * 100;
    return profile;
  }
  function saveProfile(profile) {
    saveJSON(PROFILE_KEY, profile);
  }

  function loadSetsStats() {
    return loadJSON(SETS_KEY, {});
  }
  function saveSetsStats(stats) {
    saveJSON(SETS_KEY, stats);
  }

  function loadEvents() {
    return loadJSON(EVENTS_KEY, []);
  }
  function saveEvents(ev) {
    saveJSON(EVENTS_KEY, ev);
  }

  function loadSession() {
    return loadJSON(SESSION_KEY, null);
  }
  function saveSession(sess) {
    saveJSON(SESSION_KEY, sess);
  }

  // --- Gamepad configuration ---
  const CONFIG_KEY = 'mcq_gamepad_cfg_v1';
  const DEFAULT_CONFIG = {
    deadzone: 0.3,
    vertical: false,
    axis: {
      index: 1,      // axis index for vertical movement (1 = Y axis)
      invert: false, // invert direction of axis
      threshold: 0.6, // threshold for movement detection after deadzone
      repeatDelay: 300, // ms before repeating when axis held
      repeatRate: 200   // ms between repeats after initial delay
    },
    buttons: {
      choose: [0],        // A
      next: [1, 9, 5],    // B, Start, R
      prev: [2, 4],       // X, L
      restart: [8],       // Select / Minus
      toggleDrill: [16],  // Home / Plus
      toggleImport: [17]  // Capture / Minus (varies by controller)
    }
  };

  function loadConfig(){
    try {
      const txt = localStorage.getItem(CONFIG_KEY);
      if(!txt) return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      const cfg = JSON.parse(txt);
      // merge missing fields from default
      const merged = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      Object.assign(merged, cfg);
      if(cfg.axis) Object.assign(merged.axis, cfg.axis);
      if(cfg.buttons) merged.buttons = Object.assign({}, DEFAULT_CONFIG.buttons, cfg.buttons);
      return merged;
    } catch(e){
      return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
    }
  }
  function saveConfig(cfg){
    localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg));
  }

  let gamepadConfig = loadConfig();
  let testerButtonsElems = [];
  // axis state for repeat logic
  let axisState = { dir: 0, holdStart: 0, lastTrigger: 0, repeated: false };

  // --- State ---
  const SETS = new Map(); // key -> { title, file, items }
  let QUESTIONS = [];
  let order = [];
  let idx = 0;
  let hoverIndex = 0;
  let session = loadSession() || { activeSetKey: null, answered: {}, awardedSetBonus: false };

  // --- Elements ---
  const els = {
    tabImport: document.getElementById('tab-import'),
    tabDrill: document.getElementById('tab-drill'),
    viewImport: document.getElementById('view-import'),
    viewDrill: document.getElementById('view-drill'),
    goDrillBtn: document.getElementById('goDrillBtn'),
    inputArea: document.getElementById('inputArea'),
    loadBtn: document.getElementById('loadBtn'),
    demoBtn: document.getElementById('demoBtn'),
    downloadTemplateBtn: document.getElementById('downloadTemplateBtn'),
    setSelect: document.getElementById('setSelect'),
    setsList: document.getElementById('setsList'),
    levelSummary: document.getElementById('levelSummary'),
    levelBar: document.getElementById('levelBar'),
    currentLevelBreakdown: document.getElementById('currentLevelBreakdown'),
    setStats: document.getElementById('setStats'),
    quizBox: document.getElementById('quizBox'),
    emptyState: document.getElementById('emptyState'),
    stem: document.getElementById('stem'),
    options: document.getElementById('options'),
    notes: document.getElementById('notes'),
    nextBtn: document.getElementById('nextBtn'),
    prevBtn: document.getElementById('prevBtn'),
    progressPill: document.getElementById('progressPill'),
    xpPill: document.getElementById('xpPill'),
    bar: document.getElementById('bar'),
    statusText: document.getElementById('statusText'),
    resetBtn: document.getElementById('resetBtn'),
  };

  // --- View helpers ---
  function setActiveView(name){
    const isImport = name === 'import';
    els.viewImport.classList.toggle('active', isImport);
    els.viewDrill.classList.toggle('active', !isImport);
    els.tabImport.classList.toggle('active', isImport);
    els.tabDrill.classList.toggle('active', !isImport);
  }

  // --- Load sets from /questions/index.json ---
  async function fetchJSON(url){
    const resp = await fetch(url, { cache:'no-store' });
    if(!resp.ok) throw new Error(`${url} ‚Üí HTTP ${resp.status}`);
    return await resp.json();
  }

  function normalizeSetPayload(payload, fallbackTitle){
    if(Array.isArray(payload)){
      return { title: fallbackTitle, items: payload };
    }
    const title = payload.title || fallbackTitle || 'Untitled';
    const items = payload.questions || payload.items || payload.data || payload.qs || payload;
    return { title, items };
  }

  async function loadIndex(){
    try {
      const idxData = await fetchJSON('questions/index.json');
      let entries = [];
      if (Array.isArray(idxData)) {
        if (idxData.length && typeof idxData[0] === 'string') {
          entries = idxData.map(f => ({ file: String(f), title: null }));
        } else {
          entries = idxData.map(o => ({ file: o.file || o.path || o.url || '', title: o.title || null })).filter(e => e.file);
        }
      } else if (idxData && idxData.files) {
        entries = idxData.files.map(f => typeof f === 'string' ? ({file:f, title:null}) : ({file:f.file, title:f.title||null}));
      }
      if (!entries.length) throw new Error('index.json has no entries');

      // populate selector and list
      els.setSelect.innerHTML = '';
      els.setsList.innerHTML = '';
      for (const entry of entries) {
        const file = entry.file.startsWith('questions/') ? entry.file : `questions/${entry.file}`;
        try {
          const payload = await fetchJSON(file);
          const base = file.split('/').pop().replace(/\.json$/i,'');
          const { title, items } = normalizeSetPayload(payload, entry.title || base);
          SETS.set(base, { title, file, items });

          // dropdown
          const opt = document.createElement('option');
          opt.value = base; opt.textContent = title;
          els.setSelect.appendChild(opt);

          // list view
          const row = document.createElement('div');
          row.innerHTML = `<b>${title}</b> <span class="muted">(${base}.json)</span>`;
          els.setsList.appendChild(row);
        } catch(err) {
          console.error('Failed loading', file, err);
        }
      }
      const firstKey = [...SETS.keys()][0];
      if(firstKey){ els.setSelect.value = firstKey; applySet(firstKey); }
      else { els.setSelect.innerHTML = '<option disabled selected>No sets found</option>'; els.setsList.textContent='No sets found.'; }
    } catch(err){
      console.error('Index load error', err);
      els.setSelect.innerHTML = '<option disabled selected>index.json missing</option>';
      els.setsList.textContent = 'Could not load /questions/index.json. Create one listing your JSON files.';
    }
  }

  function parseInput(text){
    try{
      const data = JSON.parse(text);
      if(!Array.isArray(data)) throw new Error('Top-level JSON must be an array');
      data.forEach((q, i) => {
        if (typeof q.stem !== 'string') throw new Error(`Item ${i+1} missing "stem"`);
        if (!Array.isArray(q.options) || q.options.length !== 4) throw new Error(`Item ${i+1} must have 4 options`);
        if (!('answer' in q)) throw new Error(`Item ${i+1} missing "answer" (0-3 or matching option text)`);
        if (typeof q.notes !== 'string') throw new Error(`Item ${i+1} missing "notes" (string)`);
        if (typeof q.answer === 'number') {
          if (q.answer < 0 || q.answer > 3) throw new Error(`Item ${i+1} answer index must be 0-3`);
        } else if (typeof q.answer === 'string') {
          const ai = q.options.findIndex(o => o.trim().toLowerCase() === q.answer.trim().toLowerCase());
          if(ai < 0) throw new Error(`Item ${i+1} answer text not found in options`);
          q.answer = ai;
        } else {
          throw new Error(`Item ${i+1} answer must be number or string`);
        }
        if(!q.id) q.id = `q-${i+1}`;
      });
      return data;
    } catch(e) {
      alert('Import error: ' + e.message);
      return null;
    }
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]} return a; }

  function applySet(key){
    const set = SETS.get(key);
    if(!set){ return; }
    const text = JSON.stringify(set.items);
    loadQuestions(text);
    // new session for this set
    session = { activeSetKey: key, answered: {}, awardedSetBonus: false };
    saveSession(session);
    // increment runs for set
    let stats = loadSetsStats();
    if(!stats[key]) stats[key] = { runs:0, totalCompletions:0, xpTotal:0 };
    stats[key].runs = (stats[key].runs || 0) + 1;
    saveSetsStats(stats);
    updateSetStatsUI();
  }

  function loadQuestions(jsonText){
    const data = parseInput(jsonText);
    if(!data) return;
    QUESTIONS = data.map(q=>({...q}));
    order = [...Array(QUESTIONS.length).keys()];
    shuffle(order);
    idx = 0; hoverIndex = 0;
    els.emptyState.classList.add('hidden');
    els.quizBox.classList.remove('hidden');
    // If no active set key (manual import/demo), assign a default key so XP aggregates somewhere
    if(!session.activeSetKey){
      session.activeSetKey = 'manual';
      saveSession(session);
    }
    render();
    setActiveView('drill');
  }

  function updateXPUI(){
    const profile = loadProfile();
    els.xpPill.textContent = `XP: ${profile.totalXP.toFixed(1)} ¬∑ Level ${profile.level}`;
    // level progress
    const progress = (profile.totalXP - profile.levelStartXP) / 100;
    els.levelBar.style.width = `${Math.min(progress,1)*100}%`;
    // breakdown
    const events = loadEvents();
    const xpForLevel = profile.totalXP - profile.levelStartXP;
    let remain = xpForLevel;
    const contrib = {};
    for(let i=events.length-1; i>=0 && remain > 0; i--){
      const e = events[i];
      let x = Math.min(e.xp, remain);
      contrib[e.set] = (contrib[e.set] || 0) + x;
      remain -= x;
    }
    const breakdownEl = els.currentLevelBreakdown;
    if(xpForLevel <= 0){
      breakdownEl.textContent = 'No XP earned yet.';
    } else {
      let items = [];
      const keys = Object.keys(contrib).sort((a,b)=>contrib[b]-contrib[a]);
      for(const k of keys){
        const xp = contrib[k];
        const percent = ((xp / xpForLevel) * 100).toFixed(0);
        const set = SETS.get(k);
        const title = set ? set.title : k;
        items.push(`<div><b>${title}</b>: ${xp.toFixed(1)} XP (${percent}%)</div>`);
      }
      breakdownEl.innerHTML = items.join('');
    }
    updateSetStatsUI();
  }

  // Update per-set stats table
  function updateSetStatsUI(){
    const stats = loadSetsStats();
    const listEl = els.setStats;
    if(!stats || Object.keys(stats).length === 0){
      listEl.innerHTML = '<div class="muted">No runs yet.</div>';
      return;
    }
    let html = '<table style="width:100%; border-collapse: collapse;"><thead><tr><th style="text-align:left;">Set</th><th style="text-align:center;">Runs</th><th style="text-align:center;">Completions</th><th style="text-align:center;">XP</th></tr></thead><tbody>';
    for(const key of Object.keys(stats)){
      const st = stats[key];
      const set = SETS.get(key);
      const title = set ? set.title : key;
      html += `<tr><td>${title}</td><td style="text-align:center;">${st.runs || 0}</td><td style="text-align:center;">${st.totalCompletions || 0}</td><td style="text-align:center;">${(st.xpTotal || 0).toFixed(1)}</td></tr>`;
    }
    html += '</tbody></table>';
    listEl.innerHTML = html;
  }

  // Initialize controller tester/config UI
  function initControllerPanel(){
    // Build button tester display for first 18 buttons
    const btnContainer = document.getElementById('testerButtons');
    if(btnContainer){
      btnContainer.innerHTML = '';
      testerButtonsElems = [];
      for(let i=0; i<18; i++){
        const span = document.createElement('div');
        span.className = 'tester-btn';
        span.textContent = i;
        testerButtonsElems.push(span);
        btnContainer.appendChild(span);
      }
    }
    // Build axes display for first two axes
    const axesContainer = document.getElementById('testerAxes');
    if(axesContainer){
      axesContainer.innerHTML = '';
      for(let i=0; i<2; i++){
        const axisContainer = document.createElement('div');
        axisContainer.className = 'tester-axis';
        const bar = document.createElement('div');
        bar.className = 'tester-axis-bar';
        bar.style.left = '50%';
        bar.style.width = '0%';
        axisContainer.appendChild(bar);
        const label = document.createElement('div');
        label.className = 'small muted';
        label.style.marginTop = '2px';
        label.textContent = `Axis ${i}: 0`;
        axisContainer.appendChild(label);
        axesContainer.appendChild(axisContainer);
      }
    }
    // Populate config inputs
    const dzInput = document.getElementById('deadzoneInput');
    const dzValue = document.getElementById('deadzoneValue');
    if(dzInput && dzValue){
      dzInput.value = gamepadConfig.deadzone;
      dzValue.textContent = gamepadConfig.deadzone;
      dzInput.addEventListener('input', () => {
        dzValue.textContent = dzInput.value;
        gamepadConfig.deadzone = parseFloat(dzInput.value);
      });
    }
    const vertInput = document.getElementById('verticalInput');
    if(vertInput){
      vertInput.checked = !!gamepadConfig.vertical;
      vertInput.addEventListener('change', () => {
        const checked = vertInput.checked;
        gamepadConfig.vertical = checked;
        if(checked){
          gamepadConfig.axis.index = 0;
          gamepadConfig.axis.invert = false;
        } else {
          gamepadConfig.axis.index = 1;
          gamepadConfig.axis.invert = false;
        }
      });
    }
    // Build mapping list
    const mappingList = document.getElementById('mappingList');
    if(mappingList){
      mappingList.innerHTML = '';
      const actions = ['choose','next','prev','restart','toggleDrill','toggleImport'];
      actions.forEach(action => {
        const row = document.createElement('div');
        row.className = 'mapping-row';
        const label = document.createElement('label');
        label.textContent = action.charAt(0).toUpperCase() + action.slice(1);
        row.appendChild(label);
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.action = action;
        input.value = (gamepadConfig.buttons[action] || []).join(',');
        row.appendChild(input);
        mappingList.appendChild(row);
      });
      const saveBtn = document.getElementById('saveConfigBtn');
      const resetBtn = document.getElementById('resetConfigBtn');
      if(saveBtn){
        saveBtn.onclick = () => {
          const inputs = mappingList.querySelectorAll('input[data-action]');
          inputs.forEach(inp => {
            const act = inp.dataset.action;
            const vals = inp.value.split(',').map(s => parseInt(s.trim(),10)).filter(n => !isNaN(n));
            gamepadConfig.buttons[act] = vals;
          });
          saveConfig(gamepadConfig);
          alert('Controller config saved.');
        };
      }
      if(resetBtn){
        resetBtn.onclick = () => {
          gamepadConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
          saveConfig(gamepadConfig);
          initControllerPanel();
          alert('Controller config reset to default.');
        };
      }
    }
  }

  // Update tester UI with live gamepad state
  function updateTesterUI(gp){
    const statusEl = document.getElementById('controllerStatus');
    if(statusEl){
      statusEl.textContent = gp ? `Gamepad: ${gp.id || 'Unknown'} (index ${gp.index})` : 'No gamepad connected.';
    }
    // update button states
    if(gp && testerButtonsElems.length){
      gp.buttons.forEach((b,i) => {
        const elem = testerButtonsElems[i];
        if(elem){
          elem.classList.toggle('active', !!b.pressed);
        }
      });
    }
    // update axes
    const axesContainer = document.getElementById('testerAxes');
    if(gp && axesContainer){
      const axes = gp.axes || [];
      const children = axesContainer.children;
      for(let i=0; i<Math.min(2, children.length); i++){
        const axisContainer = children[i];
        const val = axes[i] || 0;
        const bar = axisContainer.querySelector('.tester-axis-bar');
        if(bar){
          const width = Math.abs(val) * 50;
          if(val >= 0){
            bar.style.left = '50%';
            bar.style.width = `${width}%`;
          } else {
            bar.style.left = `${50 - width}%`;
            bar.style.width = `${width}%`;
          }
        }
        const label = axisContainer.querySelector('.small');
        if(label){
          label.textContent = `Axis ${i}: ${val.toFixed(2)}`;
        }
      }
    }
  }

  // Handle axis movement with repeat logic
  function handleAxis(gp, ts){
    const cfg = gamepadConfig;
    const axisIdx = cfg.axis.index;
    let val = (gp.axes && gp.axes.length > axisIdx) ? gp.axes[axisIdx] : 0;
    if(cfg.axis.invert) val = -val;
    // apply deadzone
    const dz = cfg.deadzone != null ? cfg.deadzone : 0.3;
    if(Math.abs(val) < dz){
      val = 0;
    } else {
      const sign = val > 0 ? 1 : -1;
      const mag = (Math.abs(val) - dz) / (1 - dz);
      val = sign * mag;
    }
    const threshold = cfg.axis.threshold;
    let dir = 0;
    if(val > threshold) dir = 1;
    else if(val < -threshold) dir = -1;
    if(dir !== 0){
      if(axisState.dir !== dir){
        // immediate trigger on direction change
        if(dir === 1) moveHover(1); else moveHover(-1);
        axisState.dir = dir;
        axisState.holdStart = ts;
        axisState.lastTrigger = ts;
        axisState.repeated = false;
      } else {
        const sinceHold = ts - axisState.holdStart;
        const sinceLast = ts - axisState.lastTrigger;
        if(!axisState.repeated){
          if(sinceHold > cfg.axis.repeatDelay){
            if(dir === 1) moveHover(1); else moveHover(-1);
            axisState.lastTrigger = ts;
            axisState.repeated = true;
          }
        } else {
          if(sinceLast > cfg.axis.repeatRate){
            if(dir === 1) moveHover(1); else moveHover(-1);
            axisState.lastTrigger = ts;
          }
        }
      }
    } else {
      axisState.dir = 0;
      axisState.repeated = false;
    }
  }

  // Handle button presses with custom mapping
  function handleButtons(gp){
    const cfg = gamepadConfig;
    const btns = gp.buttons;
    const actions = Object.keys(cfg.buttons);
    for(const act of actions){
      const indices = cfg.buttons[act] || [];
      indices.forEach(idxBtn => {
        if(pressedEdge(idxBtn, btns)){
          if(act === 'choose'){
            const current = QUESTIONS[order[idx]];
            if(current){ choose(hoverIndex); }
          } else if(act === 'next'){
            next();
          } else if(act === 'prev'){
            prev();
          } else if(act === 'restart'){
            restart(true);
          } else if(act === 'toggleDrill'){
            setActiveView('drill');
          } else if(act === 'toggleImport'){
            setActiveView('import');
          }
        }
      });
    }
  }

  function awardXP(xp, setKey, type){
    if(xp <= 0) return;
    // update profile
    const profile = loadProfile();
    profile.totalXP += xp;
    const newLevel = Math.floor(profile.totalXP / 100) + 1;
    if(newLevel > profile.level){
      // adjust levelStartXP to new threshold
      profile.level = newLevel;
      profile.levelStartXP = Math.floor(profile.totalXP / 100) * 100;
    }
    saveProfile(profile);
    // update sets stats
    const stats = loadSetsStats();
    if(!stats[setKey]) stats[setKey] = { runs:0, totalCompletions:0, xpTotal:0 };
    stats[setKey].xpTotal = (stats[setKey].xpTotal || 0) + xp;
    saveSetsStats(stats);
    // record event
    const ev = loadEvents();
    ev.push({ ts: Date.now(), set: setKey, type, xp });
    // limit length
    if(ev.length > 1000) ev.shift();
    saveEvents(ev);
    // update UI
    updateXPUI();
  }

  function checkSetCompletion(){
    if(session.awardedSetBonus) return;
    const allCorrect = QUESTIONS.every(q => {
      const st = session.answered[q.id];
      return st && st.correct;
    });
    if(allCorrect){
      const bonus = QUESTIONS.length * 2.5;
      awardXP(bonus, session.activeSetKey, 'set_bonus');
      session.awardedSetBonus = true;
      // update completions
      const stats = loadSetsStats();
      const s = stats[session.activeSetKey] || { runs:0, totalCompletions:0, xpTotal:0 };
      s.totalCompletions = (s.totalCompletions || 0) + 1;
      stats[session.activeSetKey] = s;
      saveSetsStats(stats);
      saveSession(session);
      alert(`üéâ Set complete! +${bonus} XP bonus earned.`);
    }
  }

  function render(){
    const current = QUESTIONS[order[idx]];
    const total = QUESTIONS.length;
    els.progressPill.textContent = `${idx+1} / ${total}`;
    els.bar.style.width = `${((idx)/total)*100}%`;
    els.statusText.textContent = `Question ${idx+1} of ${total}`;

    els.stem.textContent = current.stem;
    els.options.innerHTML = '';
    els.notes.classList.add('hidden');
    els.notes.textContent = '';

    const st = session.answered[current.id];

    current.options.forEach((opt, i) => {
      const b = document.createElement('button');
      b.className = 'opt';
      b.textContent = opt;
      if(st && st.correct){
        b.classList.add(i === current.answer ? 'correct' : '');
        b.disabled = true;
      } else {
        if(i === hoverIndex) b.classList.add('hovered');
      }
      b.addEventListener('click', () => choose(i));
      els.options.appendChild(b);
    });
    els.prevBtn.disabled = idx === 0;
    // next always enabled
    if(st && st.correct){
      // show notes if correct
      showNotes(current);
    }
  }

  function showNotes(q){
    els.notes.classList.remove('hidden');
    els.notes.textContent = q.notes || '(No notes provided)';
  }

  function choose(i){
    const current = QUESTIONS[order[idx]];
    const key = current.id;
    let st = session.answered[key];
    if(st && st.correct) return;
    if(!st){
      st = { wrongs:0, correct:false, awarded:false };
      session.answered[key] = st;
    }
    if(i !== current.answer){
      // wrong attempt
      st.wrongs++;
      // decorate button
      [...els.options.children].forEach((b,k)=>{
        if(k === i){
          b.classList.add('wrong');
        }
        b.disabled = true;
      });
      // allow retry by enabling buttons after slight delay
      setTimeout(() => {
        render();
      }, 600);
      saveSession(session);
      return;
    }
    // correct
    st.correct = true;
    // compute xp if not awarded
    if(!st.awarded){
      const xp = 5 * Math.pow(0.5, st.wrongs);
      awardXP(xp, session.activeSetKey, 'question');
      st.awarded = true;
    }
    // decorate
    [...els.options.children].forEach((b,k)=>{
      b.disabled = true;
      b.classList.remove('hovered');
      b.classList.toggle('correct', k === current.answer);
    });
    showNotes(current);
    saveSession(session);
    checkSetCompletion();
  }

  function next(){
    if(idx < order.length - 1){
      idx += 1; hoverIndex = 0; render();
    } else {
      // finished run
      els.bar.style.width = '100%';
      const total = QUESTIONS.length;
      const correctCount = Object.values(session.answered).filter(v => v && v.correct).length;
      alert(`Run finished! You eventually got ${correctCount}/${total} correct. You can retry questions as many times as needed.`);
      if(confirm('Run the set again (reshuffle)?')){ restart(true); }
    }
  }

  function prev(){
    if(idx > 0){
      idx -= 1;
      hoverIndex = 0;
      render();
    }
  }

  function restart(reshuffle=false){
    idx = 0; hoverIndex = 0;
    session.answered = {};
    session.awardedSetBonus = false;
    saveSession(session);
    if(reshuffle){ shuffle(order); }
    render();
  }

  // --- Events: Tabs / Nav ---
  window.addEventListener('DOMContentLoaded', () => {
    loadIndex();
    updateXPUI();
    initControllerPanel();
  });

  els.setSelect && els.setSelect.addEventListener('change', (e) => {
    applySet(e.target.value);
  });

  els.tabImport.addEventListener('click', () => setActiveView('import'));
  els.tabDrill.addEventListener('click', () => setActiveView('drill'));
  els.goDrillBtn.addEventListener('click', () => setActiveView('drill'));

  els.loadBtn.addEventListener('click', () => loadQuestions(els.inputArea.value.trim()));

  els.demoBtn.addEventListener('click', () => {
    const demo = [
      {id:'d1', stem:'Beta-blockers ‚Üì what cardiac parameter at rest and exercise?', options:['Contractility','Preload','Afterload','Heart rate'], answer:3, notes:'Œ≤-blockers primarily lower HR (negative chronotropy) and contractility (negative inotropy). Clinically, HR reduction is the most reliable exam answer.'},
      {id:'d2', stem:'Which nerve is compressed in carpal tunnel syndrome?', options:['Ulnar','Radial','Median','Musculocutaneous'], answer:2, notes:'Median nerve compression under the flexor retinaculum. Thenar weakness, paresthesia of lateral 3¬Ω digits, positive Phalen/Tinel.'},
      {id:'d3', stem:'A newborn with delayed passage of meconium‚Äîmost likely diagnosis?', options:['Hirschsprung disease','Intussusception','Pyloric stenosis','Necrotizing enterocolitis'], answer:0, notes:'Failure of neural crest cell migration ‚Üí aganglionosis of distal colon. Explosive stool after DRE; transition zone on contrast enema; confirm with rectal suction biopsy.'},
      {id:'d4', stem:'What organism causes pneumonia with ‚Äúcurrant jelly‚Äù sputum in alcohol use disorder?', options:['Streptococcus pneumoniae','Klebsiella pneumoniae','Pseudomonas aeruginosa','Legionella pneumophila'], answer:1, notes:'Klebsiella ‚Üí aspiration risk, upper-lobe abscesses, thick mucoid sputum; capsule produces bulging fissure sign.'},
      {id:'d5', stem:'Best next step for suspected ectopic pregnancy with hemodynamic instability?', options:['Methotrexate','Expectant management','Serial Œ≤-hCG','Immediate surgical exploration'], answer:3, notes:'Unstable + suspected ectopic ‚Üí urgent laparoscopy/laparotomy. Methotrexate only for stable, unruptured cases.'}
    ];
    els.inputArea.value = JSON.stringify(demo, null, 2);
    loadQuestions(els.inputArea.value);
  });

  els.downloadTemplateBtn.addEventListener('click', () => {
    const tmpl = [
      {id:'unique-id-1', stem:'Your question here', options:['A','B','C','D'], answer:0, notes:'Paste the relevant notes/explanation here.'}
    ];
    const blob = new Blob([JSON.stringify(tmpl,null,2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'mcq_template.json';
    a.click();
  });

  els.nextBtn.addEventListener('click', next);
  els.prevBtn.addEventListener('click', prev);
  els.resetBtn.addEventListener('click', () => restart(true));

  // --- Keyboard shortcuts ---
  document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if(key==='i') setActiveView('import');
    if(key==='d') setActiveView('drill');
    if(e.key==='ArrowRight'){ next(); }
    if(e.key==='ArrowLeft'){ prev(); }
    if(['1','2','3','4'].includes(e.key)){
      const n = parseInt(e.key,10)-1;
      const current = QUESTIONS[order[idx]];
      if(current){
        choose(n);
      }
    }
    if(e.key==='ArrowUp') moveHover(-1);
    if(e.key==='ArrowDown') moveHover(1);
    if(e.key==='enter'){
      const current = QUESTIONS[order[idx]];
      if(current){
        choose(hoverIndex);
      }
    }
    if(key==='r') restart(true);
  });

  function moveHover(delta){
    const current = QUESTIONS[order[idx]];
    if(!current) return;
    const st = session.answered[current.id];
    if(st && st.correct) return;
    hoverIndex = (hoverIndex + delta + 4) % 4;
    [...els.options.children].forEach((b,k)=>{
      b.classList.toggle('hovered', k === hoverIndex);
    });
  }

  // --- Gamepad support ---
  let gpRAF = null;
  let prevButtons = [];
  let axisCooldown = 0;
  function startGamepadLoop(){
    if(gpRAF) return;
    const loop = (ts) => {
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = pads && pads[0];
      if(gp){
        handleGamepad(gp, ts);
      }
      gpRAF = requestAnimationFrame(loop);
    };
    gpRAF = requestAnimationFrame(loop);
  }
  function stopGamepadLoop(){ if(gpRAF){ cancelAnimationFrame(gpRAF); gpRAF = null; } }
  window.addEventListener('gamepadconnected', (e) => { startGamepadLoop(); console.log('Gamepad connected', e.gamepad); });
  window.addEventListener('gamepaddisconnected', (e) => { console.log('Gamepad disconnected', e.gamepad); if(!navigator.getGamepads().some(g=>g)) stopGamepadLoop(); });
  function pressedEdge(i, buttons){ return buttons[i] && buttons[i].pressed && !(prevButtons[i] && prevButtons[i].pressed); }
  function handleGamepad(gp, ts){
    // Update live tester UI
    updateTesterUI(gp);
    // Handle axis movement (with repeat logic)
    handleAxis(gp, ts);
    // Handle buttons according to custom mapping
    handleButtons(gp);
    // update previous button states for edge detection
    prevButtons = gp.buttons.map(b => ({ pressed: b.pressed }));
  }
  // start polling right away for browsers that delay event
  startGamepadLoop();
  </script>
</body>
</html>
